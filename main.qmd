---
title: "Main"
format: pdf
editor: visual
---

## Todos:

# 1) Briefly **describe** the data set (e.g., how many customers, what information are available, how do important variables look like).

\

\

```{r}
library(ggplot2)
library(ggcorrplot)
library(ggpubr)
library(rpart)
library(partykit)
library(dplyr)
library(gridExtra)
```

```{r}
set.seed(1234)
```

## Running Code

```{r}
load("Group1_streaming_ds.rda")
head(streaming_ds)
str(streaming_ds)
summary(streaming_ds)

streaming_ds["few hrs"] <- as.factor(streaming_ds$`few hrs`) # change column from boolean to factor 
```

# 2. **Identify the relevant variables** that would help you to segment/cluster/classify the users/customers and justify your choice. 

## Correlation Matrix

```{r}
streaming_only_num <- streaming_ds[sapply(streaming_ds, is.numeric)] # only get columns that are numberic

ggcorrplot(cor(streaming_only_num),
           lab = TRUE,               # Show correlation values
           lab_size = 3,             # Fix text size
           digits = 2,               # Number of decimal places
           method = "square")       # Square cells
```

No strong correlation for any of the numeric data points. However we have a few combinations which might be intersting to investigate further. Mainly: Income\~Age; Months\~Age (kind of obvious); Months\~Stopped

### Quick Viz for Columns against each other

```{r}
pairs(streaming_ds)
```

## Scatter plot for Income and age

```{r}
Age_income <- ggplot(streaming_ds, aes(x= age, y= income)) + 
  geom_point() + 
  scale_x_continuous(breaks = c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85))


Months_age <- ggplot(streaming_ds, aes(x= age, y= months)) + 
  geom_point() + 
  scale_x_continuous(breaks = c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85))

Months_stopped <- ggplot(streaming_ds, aes(x= months, y= stopped)) + 
  geom_point() + 
  scale_x_continuous(breaks= c(6, 12, 18, 24, 30, 36, 42))

Age_stopped <- ggplot(streaming_ds, aes(x=age, y = stopped)) + 
  geom_point() + 
  scale_x_continuous(breaks = c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85))


ggarrange(Age_income, Months_age, Months_stopped, Age_stopped, labels = c("Age ~ Income", "Months ~ Age", "Stopped ~ Months", "Age ~ stopped"), font.label = list(size=10), col= 1, nrow = 4)
```

Note: From the Months \~ Age plot it seem like Age and Months are not both describing the Age of the User, since this would mean a linear relationship

-\> Months is maybe the time of the subscription

### Income and Stopped

hallo

```{r}
ggplot(streaming_ds, aes(income, stopped)) +
  geom_point()
```

## Using a decision tree

### Pruning

```{r}
full_tree <- rpart(stopped ~. , data= streaming_ds, control = list(cp=0.001))

printcp(full_tree)
rpart::plotcp(full_tree)
```

### Pruned tree

From the decision tree it seems that the most important variables are the few_hrs, months, and age.

```{r}
pruned_tree <- prune(full_tree, cp = full_tree$cptable[5, "CP"])
plot(as.party(pruned_tree))
```

# 3) **Test** several models and **compare** them. **Consider the best approach** for your problem - clustering, classification, anything else?

-\> Predict if a customer is a Premium member or not Additionally predict number of stopped streams

Logistic Regression

# 4) **Justify your selection** of customers / respondents - what makes the group(s) special?

-\> Clustering to find likely customers that are not yet premium

```{r}

```

```{r}
clustering_data <- streaming_ds %>%
  select(stopped, age, income, premium, device, `living area`, months, `few hrs`) %>% 
  mutate(few_hrs = as.numeric(`few hrs`)) %>%
  mutate(device = as.numeric(device)) %>%
  mutate(living_area = as.numeric(`living area`)) %>%
  select(-`few hrs`) %>%
  select(-`living area`) %>%
  scale() %>%
  as.data.frame()

clustering_data_no_premium <- streaming_ds %>%
  filter(premium == 0) %>%
  select(stopped, age, income, premium, device, `living area`, months, `few hrs`) %>%
  mutate(few_hrs = as.numeric(`few hrs`)) %>%
  mutate(device = as.numeric(device)) %>%
  mutate(living_area = as.numeric(`living area`)) %>%
  select(-`few hrs`) %>%
  select(-`living area`) %>%
  select(-premium) %>% # drop because scaling
  scale() %>%
  as.data.frame()



str(clustering_data)
str(clustering_data_no_premium)
```

### Getting number of clusters using the elbow method

```{r}

elbow_method <- function(n_clusters, data) {
  wss <- numeric(n_clusters)
  for (i in 1:n_clusters) {
    km <- kmeans(data, centers = i, nstart = 20)
    wss[i] <- km$tot.withinss
  }
  return(wss)
}


wss_values_full <- elbow_method(10, clustering_data)
wss_values_no_premium <- elbow_method(10, clustering_data_no_premium)
```

```{r}
plot_data_full <- data.frame(k = 1:10, wss = wss_values_full) #turn wss values into df for plotting

plot_data_no_premium <- data.frame(k = 1:10, wss = wss_values_no_premium)

p1 <- ggplot(plot_data_full, aes(x = k, y = wss)) +
  geom_line() +
  geom_point() +
  labs(title = "Elbow Method for Optimal k",
       x = "Number of Clusters (k)",
       y = "Total Within Sum of Squares") +
  theme_minimal()

p2 <- ggplot(plot_data_no_premium, aes(x = k, y = wss)) +
  geom_line() +
  geom_point() +
  labs(title = "Elbow Method for Optimal k",
       x = "Number of Clusters (k)",
       y = "Total Within Sum of Squares") +
  theme_minimal()


grid.arrange(p1, p2, ncol = 2)
```

We decide to proceed with 4 clusters as the Plot shows a steep decline till the 4th point. Afterwards the decline falltens of, signaling us that 4 clusters would give us the best clarity while maintaining simplicity for the visualization.

### Performing the k-means clustering

```{r}
kmeans_full <- kmeans(clustering_data, centers = 4, nstart = 10)
kmeans_no_premium <- kmeans(clustering_data_no_premium, centers = 3, nstart = 10)


clustering_data$Cluster <- as.factor(kmeans_full$cluster)
clustering_data_no_premium$Cluster <- as.factor(kmeans_no_premium$cluster)
```

```{r}
p3 <- ggplot(clustering_data, aes(x = income, y = months, color = Cluster)) +
    geom_point(alpha = 0.6) +
    labs(title = "Clusters for full customer base") +
    theme_minimal()


p4 <- ggplot(clustering_data_no_premium, aes(x = income, y = months, color = Cluster)) +
    geom_point(alpha = 0.6) +
    labs(title = "Clusters for non-premium customers") +
    theme_minimal()

grid.arrange(p3, p4, ncol = 2)
```

```{r}
p1 <- ggplot(clustering_data_no_premium, aes(x = months, y = income)) +
  geom_point(color = "grey90", alpha = 0.5) +
  geom_point(data = subset(clustering_data_no_premium, Cluster == "2"), 
             aes(color = Cluster), size = 2, alpha = 0.6) +
  scale_color_manual(values = "blue") +
  theme_minimal() +
  labs(title = "New with low income",
       x = "Months (scaled)",
       y = "Income (scaled)") +
  theme(legend.position = "none")


p2 <- ggplot(clustering_data_no_premium, aes(x= months, y = income)) +
  # Add background points in grey
  geom_point(color = "grey90", alpha = 0.5) +
  # Add cluster points in color
  geom_point(data = subset(clustering_data_no_premium, Cluster == "1"), 
             aes(color = Cluster), size = 2, alpha = 0.6) +
  scale_color_manual(values = "red") +
  theme_minimal() +
  labs(title = "Medium with medium income",
       x = "Months (scaled)",
       y = "Income (scaled)") +
  theme(legend.position = "none")

# Cluster 2


# Cluster 3
p3 <- ggplot(clustering_data_no_premium, aes(x = months, y = income)) +
  geom_point(color = "grey90", alpha = 0.5) +
  geom_point(data = subset(clustering_data_no_premium, Cluster == "3"), 
             aes(color = Cluster), size = 2, alpha = 0.6) +
  scale_color_manual(values = "green4") +
  theme_minimal() +
  labs(title = "New with high income",
       x = "Months (scaled)",
       y = "Income (scaled)") +
  theme(legend.position = "none")

# Arrange plots
grid.arrange(p1, p2, p3, ncol = 3)
```

### Further visualisations for our target customer segment

```{r}
# Create a function to calculate proportions for each cluster
cluster_proportions <- function(data, factor_col, cluster_nums = c("1", "3")) {
  data %>%
    filter(Cluster %in% cluster_nums) %>%
    group_by(Cluster) %>%
    summarise(
      ios = mean(factor_col == 1),  # proportion where device = "ios"
      android = mean(factor_col == 2),  # proportion where device = "android"
      n = n()
    )
}


# Calculate proportions for device
device_props <- clustering_data_no_premium %>%
  mutate(
    device_type = ifelse(device > 0, "ios", "android")  # Assuming ios was coded as 2 and android as 1
  ) %>%
  filter(Cluster %in% c("1", "3")) %>%
  group_by(Cluster, device_type) %>%
  summarise(count = n()) %>%
  group_by(Cluster) %>%
  mutate(proportion = count / sum(count))

# Calculate proportions for living area
living_area_props <- clustering_data_no_premium %>%
  mutate(
    area_type = ifelse(living_area > 0, "rest", "urban")  # Assuming rest was coded as 2 and urban as 1
  ) %>%
  filter(Cluster %in% c("1", "3")) %>%
  group_by(Cluster, area_type) %>%
  summarise(count = n()) %>%
  group_by(Cluster) %>%
  mutate(proportion = count / sum(count))

# Create bar chart for device distribution
p1 <- ggplot(device_props, 
             aes(x = Cluster, y = proportion, fill = device_type)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_x_discrete(labels = c("1" = "Medium", "3" = "High Income")) +
  theme_minimal() +
  scale_fill_manual(values = c("android" = "#E41A1C", "ios" = "#4DAF4A")) +
  labs(title = "Device Distribution by Cluster",
       y = "Proportion",
       fill = "Device Type") +
  theme(legend.position = "bottom")

# Create bar chart for living area distribution
p2 <- ggplot(living_area_props, 
             aes(x = Cluster, y = proportion, fill = area_type)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_x_discrete(labels = c("1" = "Medium", "3" = "High Income")) +
  theme_minimal() +
  scale_fill_manual(values = c("urban" = "#377EB8", "rest" = "#984EA3")) +
  labs(title = "Living Area Distribution by Cluster",
       y = "Proportion",
       fill = "Area Type") +
  theme(legend.position = "bottom")

# Arrange plots side by side
grid.arrange(p1, p2, ncol = 2)

```

## K means for income and stopped

```{r}
ggplot(clustering_data_no_premium, aes(x = income, y = stopped, color = Cluster)) +
    geom_point(alpha = 0.6) +
    labs(title = "Clusters for non-premium customers") +
    theme_minimal()
```

The visualization shows us that the customers from the blue cluster are the ones with the most stopped streams. Green and Red clusters on the hand have relative low numbers of stopped streams with a maximum of 3 stopped streams.

## DBSCAN

```{r}
library(dbscan)

clustering_vars <- clustering_data_no_premium %>%
  select(income, stopped)
```

```{r}
# Finding optimal eps for DB SCAN
kNNdistplot(clustering_vars, k = 7)
abline(h = 0.14, col = "red", lty = 2)
```

```{r}
ggplot(clustering_vars, aes(x = income, y= stopped))+ 
  geom_point()
```

```{r}
# Perform DBSCAN clustering
dbscan_result <- dbscan(clustering_vars, eps = 0.3, minPts = 4)

# Add cluster assignments to a copy of original data
clustered_data <- clustering_data_no_premium %>%
  mutate(Cluster = factor(dbscan_result$cluster),
         # Convert -1 (noise points) to "Outlier"
         Cluster = recode(Cluster, `-1` = "Outlier"))

```

```{r}
# Create visualizations
# 1. Main scatter plot
p1 <- ggplot(clustered_data, aes(x = income, y = stopped, color = Cluster)) +
  geom_point(size = 2, alpha = 0.6) +
  theme_minimal() +
  scale_color_manual(values = c("Outlier" = "grey50", 
                               "0" = "#E41A1C", 
                               "1" = "#377EB8", 
                               "2" = "#4DAF4A",
                               "3" = "#984EA3")) +
  labs(title = "DBSCAN Clusters: Age vs Income",
       subtitle = paste("eps =", 0.5, ", minPts = 4"),
       x = "income (standardized)",
       y = "stopped (standardized)")
p1
# Arrange plots
#grid.arrange(p1, p2, p3, ncol = 2)
```

# 5) Do the data reveal **how do the chosen customers differ** from the others?
